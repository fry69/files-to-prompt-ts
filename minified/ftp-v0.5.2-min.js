#!/usr/bin/env bun
// @bun
import X from"fs";import I from"os";import $ from"path";import{fileURLToPath as b} from"url";import{execSync as B} from"child_process";function w(...q){console.log(...q)}var Z=function(...q){if(z.stdoutFile)try{X.appendFileSync(z.stdoutFile,q.join(" ")+"\n")}catch(H){Y(`Error writing to output file ${z.stdoutFile}: ${H}`)}else w(...q)};function S(...q){console.error(...q)}var Y=function(...q){if(z.stderrFile)try{X.appendFileSync(z.stderrFile,q.join(" ")+"\n")}catch(H){Y(`Error writing to error file ${z.stderrFile}: ${H}`)}else S(...q)};async function k(q,H=8192){let G=!1,Q;try{Q=X.createReadStream(q,{highWaterMark:H})}catch(K){if(K.code==="ENOENT")return!1;else throw K}for await(let K of Q)if(K instanceof Uint8Array){if(Array.from(K).some((J)=>J>127)){G=!0,Q.destroy();break}}return G}async function A(q,H){try{if(H.nbconvertName&&q.endsWith(".ipynb"))if(H.nbconvertName==="internal")await D(q,H);else await v(q,H);else if(await k(q))Y(`Warning: Skipping binary file ${q}`);else{const G=X.readFileSync(q,"utf8");Z(q),Z("---"),Z(G),Z("---")}}catch(G){Y(`Error processing file ${q}: ${G}`)}}async function D(q,H){try{const G=await X.promises.readFile(q,"utf8"),Q=JSON.parse(G);let K="";if(H.nbconvertFormat==="asciidoc")K=E(Q);else K=F(Q);Z(`${q}`),Z("---"),Z(K),Z("---")}catch(G){Y(`Error converting .ipynb file ${q}: ${G}`)}}var E=function(q){let H="";for(let G of q.cells)switch(G.cell_type){case"code":H+=`+*In[${G.execution_count}]:*+\n[source, ipython3]\n----\n${G.source.join("")}\n----\n\n`;for(let Q of G.outputs)if(Q.data["text/plain"])H+=`+*Out[${G.execution_count}]:*+\n----\n${Q.data["text/plain"]}\n----\n\n`;break;case"markdown":H+=`${G.source.join("")}\n\n`;break}return H},F=function(q){let H="";for(let G of q.cells)switch(G.cell_type){case"code":H+=`\`\`\`python\n${G.source.join("")}\n\`\`\`\n\n`;for(let Q of G.outputs)if(Q.data["text/plain"])H+=`\`\`\`\n${Q.data["text/plain"]}\n\`\`\`\n\n`;break;case"markdown":H+=`${G.source.join("")}\n\n`;break}return H};async function v(q,H){const G=await X.promises.mkdtemp($.join(I.tmpdir(),"files-to-prompt-")),Q=$.join(G,$.basename(q));try{await X.promises.copyFile(q,Q);const K=`${H.nbconvertName} --to ${H.nbconvertFormat} "${Q}"`;try{B(K,{stdio:"inherit"})}catch(j){Y(`Error running ${H.nbconvertName}: ${j}`);return}const J=H.nbconvertFormat==="markdown"?".md":`.${H.nbconvertFormat}`,W=$.join(G,`${$.basename(q,".ipynb")}${J}`),U=await X.promises.readFile(W,"utf8");Z(`${q}`),Z("---"),Z(U),Z("---")}catch(K){Y(`Error converting .ipynb file ${q}: ${K}`)}finally{await X.promises.rm(G,{recursive:!0,force:!0})}}var _=function(q,H){const{ignorePatterns:G,gitignoreRules:Q}=H;for(let K of[...Q,...G]){if(L($.basename(q),K))return!0;if(K.endsWith("/")){const J=K.slice(0,-1);if(L($.relative($.dirname(q),q),J))return!0}}return!1},T=function(q){const H=$.join(q,".gitignore");if(X.existsSync(H))return X.readFileSync(H,"utf8").split("\n").filter((G)=>G.trim()!==""&&!G.startsWith("#")).map((G)=>G.trim());return[]},L=function(q,H){return new RegExp(`^${H.replace(/\*/g,".*")}\$`).test(q)};async function V(q,H){if(X.statSync(q).isFile()){if(!_(q,H))await A(q,H)}else if(X.statSync(q).isDirectory()){let G=H;if(H.gitignoreRules.length===0){const J=H.ignoreGitignore?[]:T(q);if(J.length>0)G=structuredClone(H),G.gitignoreRules=J}const Q=X.readdirSync(q,{withFileTypes:!0}).filter((J)=>H.includeHidden||!J.name.startsWith(".")).filter((J)=>J.isFile()).map((J)=>$.join(q,J.name)),K=X.readdirSync(q,{withFileTypes:!0}).filter((J)=>H.includeHidden||!J.name.startsWith(".")).filter((J)=>J.isDirectory()).map((J)=>$.join(q,J.name));for(let J of Q)if(!_(J,G))await A(J,G);for(let J of K)if(!_(J,G))await V(J,G)}else Y(`Skipping ${q}: unsupported file type`)}async function m(){return new Promise((q,H)=>{let G="";process.stdin.on("data",(Q)=>{G+=Q.toString()}),process.stdin.on("end",()=>{q(G)}),process.stdin.on("error",(Q)=>{H(Q)})})}function y(q){const H=[],G=new Set,Q=q.trim().split("\n");for(let K of Q){const J=K.trim();if(J==="")continue;if(J.includes(":")){const W=J.split(":");if(N(W[0])&&!G.has(W[0]))G.add(W[0]),H.push(W[0])}else if(N(J)&&!G.has(J))G.add(J),H.push(J)}return H}var N=function(q){for(let H of q)if(H.charCodeAt(0)<32||H.charCodeAt(0)>126)return!1;if(q.length>1024)return!1;return!0},C=function(q,H,G,Q){for(let K=0;K<q.length;K++){const J=q[K];switch(J){case"--version":return Z(`files-to-prompt.ts ${R}`),!1;case"--include-hidden":G.includeHidden=!0;break;case"--ignore-gitignore":G.ignoreGitignore=!0;break;case"-i":case"--ignore":if(K+1<q.length)G.ignorePatterns.push(q[++K]);else return Y("Error: --ignore option requires a pattern"),!0;break;case"--output":case"-o":if(K+1<q.length){Q.stdoutFile=q[++K];try{X.writeFileSync(Q.stdoutFile,""),X.truncateSync(Q.stdoutFile)}catch(W){return Y(`Error writing to output file ${Q.stdoutFile}: ${W}`),Q.stdoutFile="",!0}}else return Y("Error: --output option requires a file path"),!0;break;case"--nbconvert":if(K+1<q.length)G.nbconvertName=q[++K];else return Y("Error: --nbconvert option requires the filename or full path of the tool or \'internal\'"),!0;if(G.nbconvertName!=="internal")try{B(`${G.nbconvertName} --version`,{stdio:"ignore"})}catch(W){Y(`Warning: ${G.nbconvertName} command not found`),G.nbconvertName=""}break;case"--format":if(K+1<q.length){const W=q[++K];if(W==="asciidoc"||W==="markdown")G.nbconvertFormat=W;else return Y(`Error: Unsupported format '${W}', use 'asciidoc' or 'markdown'`),!0}else return Y("Error: --format option requires a format"),!0;break;default:if(J.startsWith("-"))return Y(`Error: Unsupported option '${J}'`),!0;H.push(J)}}return!1};async function O(q,H){for(let G of q){if(!X.existsSync(G)){Y(`Path does not exist: ${G}`);return}await V(G,H)}}async function x(q){return new Promise((H,G)=>{const Q={includeHidden:!1,ignoreGitignore:!1,ignorePatterns:[],gitignoreRules:[],nbconvertName:"",nbconvertFormat:"asciidoc"},K=[];if(C(q,K,Q,z)){H();return}if(M.isNode&&!process.stdin.isTTY||M.isDeno&&!Deno.stdin.isTerminal())m().then((W)=>{const U=y(W);return K.push(...U),O(K,Q)}).then(()=>H()).catch((W)=>G(W));else O(K,Q).then(()=>H()).catch((W)=>G(W))})}var R="v0.5.2",M={isDeno:!1,isNode:!1},z={stdoutFile:"",stderrFile:""};if(import.meta.main||process.argv[1]===b(import.meta.url))if(typeof Deno!=="undefined")M.isDeno=!0,await x(Deno.args);else M.isNode=!0,await x(process.argv.slice(2));export{y as parseFilePathsFromStdin,x as main,k as isBinaryFile,w as consoleOutput,S as consoleError};
