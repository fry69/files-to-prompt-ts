#!/usr/bin/env bun
// @bun
import Q from"fs";import R from"os";import Z from"path";import{fileURLToPath as V} from"url";import{execSync as z} from"child_process";function w(...q){console.log(...q)}var Y=function(...q){if($.stdoutFile)try{Q.appendFileSync($.stdoutFile,q.join(" ")+"\n")}catch(W){X(`Error writing to output file ${$.stdoutFile}: ${W}`)}else w(...q)};function S(...q){console.error(...q)}var X=function(...q){if($.stderrFile)try{Q.appendFileSync($.stderrFile,q.join(" ")+"\n")}catch(W){X(`Error writing to error file ${$.stderrFile}: ${W}`)}else S(...q)};async function b(q,W=8192){let H=!1,J;try{J=Q.createReadStream(q,{highWaterMark:W})}catch(O){if(O.code==="ENOENT")return!1;else throw O}for await(let O of J)if(O instanceof Uint8Array){if(Array.from(O).some((K)=>K>127)){H=!0,J.destroy();break}}return H}async function L(q,W){try{if(W.nbconvertName&&q.endsWith(".ipynb"))if(W.nbconvertName==="internal")await k(q,W);else await E(q,W);else if(await b(q))X(`Warning: Skipping binary file ${q}`);else{const H=Q.readFileSync(q,"utf8");Y(q),Y("---"),Y(H),Y("---")}}catch(H){X(`Error processing file ${q}: ${H}`)}}async function k(q,W){try{const H=await Q.promises.readFile(q,"utf8"),J=JSON.parse(H);let O="";if(W.convertFormat==="asciidoc")O=v(J);else O=D(J);Y(`${q}`),Y("---"),Y(O),Y("---")}catch(H){X(`Error converting .ipynb file ${q}: ${H}`)}}var v=function(q){let W="";for(let H of q.cells)switch(H.cell_type){case"code":W+=`+*In[${H.execution_count}]:*+\n[source, ipython3]\n----\n${H.source.join("")}\n----\n\n`;for(let J of H.outputs)if(J.data["text/plain"])W+=`+*Out[${H.execution_count}]:*+\n----\n${J.data["text/plain"]}\n----\n\n`;break;case"markdown":W+=`${H.source.join("")}\n\n`;break}return W},D=function(q){let W="";for(let H of q.cells)switch(H.cell_type){case"code":W+=`\`\`\`python\n${H.source.join("")}\n\`\`\`\n\n`;for(let J of H.outputs)if(J.data["text/plain"])W+=`\`\`\`\n${J.data["text/plain"]}\n\`\`\`\n\n`;break;case"markdown":W+=`${H.source.join("")}\n\n`;break}return W};async function E(q,W){const H=await Q.promises.mkdtemp(Z.join(R.tmpdir(),"files-to-prompt-")),J=Z.join(H,Z.basename(q));try{await Q.promises.copyFile(q,J);const O=`${W.nbconvertName} --to ${W.convertFormat} "${J}"`;try{z(O,{stdio:"inherit"})}catch(N){X(`Error running ${W.nbconvertName}: ${N}`);return}const K=W.convertFormat==="markdown"?".md":`.${W.convertFormat}`,j=Z.join(H,`${Z.basename(q,".ipynb")}${K}`),x=await Q.promises.readFile(j,"utf8");Y(`${q}`),Y("---"),Y(x),Y("---")}catch(O){X(`Error converting .ipynb file ${q}: ${O}`)}finally{await Q.promises.rm(H,{recursive:!0,force:!0})}}var G=function(q,W){const{ignorePatterns:H,gitignoreRules:J}=W;for(let O of[...J,...H]){if(M(Z.basename(q),O))return!0;if(O.endsWith("/")){const K=O.slice(0,-1);if(M(Z.relative(Z.dirname(q),q),K))return!0}}return!1},F=function(q){const W=Z.join(q,".gitignore");if(Q.existsSync(W))return Q.readFileSync(W,"utf8").split("\n").filter((H)=>H.trim()!==""&&!H.startsWith("#")).map((H)=>H.trim());return[]},M=function(q,W){return new RegExp(`^${W.replace(/\*/g,".*")}\$`).test(q)};async function B(q,W){if(Q.statSync(q).isFile()){if(!G(q,W))await L(q,W)}else if(Q.statSync(q).isDirectory()){let H=W;if(W.gitignoreRules.length===0){const K=W.ignoreGitignore?[]:F(q);if(K.length>0)H=structuredClone(W),H.gitignoreRules=K}const J=Q.readdirSync(q,{withFileTypes:!0}).filter((K)=>W.includeHidden||!K.name.startsWith(".")).filter((K)=>K.isFile()).map((K)=>Z.join(q,K.name)),O=Q.readdirSync(q,{withFileTypes:!0}).filter((K)=>W.includeHidden||!K.name.startsWith(".")).filter((K)=>K.isDirectory()).map((K)=>Z.join(q,K.name));for(let K of J)if(!G(K,H))await L(K,H);for(let K of O)if(!G(K,H))await B(K,H)}else X(`Skipping ${q}: unsupported file type`)}async function T(){return new Promise((q,W)=>{let H="";process.stdin.on("data",(J)=>{H+=J.toString()}),process.stdin.on("end",()=>{q(H)}),process.stdin.on("error",(J)=>{W(J)})})}function m(q){const W=[],H=new Set,J=q.trim().split("\n");for(let O of J){const K=O.trim();if(K==="")continue;if(K.includes(":")){const j=K.split(":");if(U(j[0])&&!H.has(j[0]))H.add(j[0]),W.push(j[0])}else if(U(K)&&!H.has(K))H.add(K),W.push(K)}return W}var U=function(q){for(let W of q)if(W.charCodeAt(0)<32||W.charCodeAt(0)>126)return!1;if(q.length>1024)return!1;return!0};async function _(q){const W={includeHidden:!1,ignoreGitignore:!1,ignorePatterns:[],gitignoreRules:[],nbconvertName:"",convertFormat:"asciidoc"};let H=[];for(let J=0;J<q.length;J++){const O=q[J];switch(O){case"--version":Y(`files-to-prompt.ts version ${I}`);return;case"--include-hidden":W.includeHidden=!0;break;case"--ignore-gitignore":W.ignoreGitignore=!0;break;case"-i":case"--ignore":if(J+1<q.length)W.ignorePatterns.push(q[++J]);else{X("Error: --ignore option requires a pattern");return}break;case"--output":case"-o":if(J+1<q.length){$.stdoutFile=q[++J];try{Q.writeFileSync($.stdoutFile,""),Q.truncateSync($.stdoutFile)}catch(K){X(`Error writing to output file ${$.stdoutFile}: ${K}`),$.stdoutFile="";return}}else{X("Error: --output option requires a file path");return}break;case"--nbconvert":if(J+1<q.length)W.nbconvertName=q[++J];else{X("Error: --nbconvert option requires the filename or full path of the tool or \'internal\'");return}if(W.nbconvertName!=="internal")try{z(`${W.nbconvertName} --version`,{stdio:"ignore"})}catch(K){X(`Warning: ${W.nbconvertName} command not found`),W.nbconvertName=""}break;case"--format":if(J+1<q.length){const K=q[++J];if(K==="asciidoc"||K==="markdown")W.convertFormat=K;else{X(`Error: Unsupported format '${K}', use 'asciidoc' or 'markdown'`);return}}else{X("Error: --format option requires a format");return}break;default:if(O.startsWith("-")){X(`Error: Unsupported option '${O}'`);return}H.push(O)}}if(A.isNode&&!process.stdin.isTTY||A.isDeno&&!Deno.stdin.isTerminal()){const J=await T(),O=m(J);H.push(...O)}for(let J of H){if(!Q.existsSync(J)){X(`Path does not exist: ${J}`);return}await B(J,W)}return}var I="0.5.0",A={isDeno:!1,isNode:!1},$={stdoutFile:"",stderrFile:""};if(import.meta.main||process.argv[1]===V(import.meta.url))if(typeof Deno!=="undefined")A.isDeno=!0,await _(Deno.args);else A.isNode=!0,await _(process.argv.slice(2));export{m as parseFilePathsFromStdin,_ as main,b as isBinaryFile,w as consoleOutput,S as consoleError};
