#!/usr/bin/env bun
// @bun
import W from"fs";import V from"os";import z from"path";import{fileURLToPath as I} from"url";import{execSync as O} from"child_process";function w(...$){console.log(...$)}var Z=function(...$){if(G.stdoutFile)try{W.appendFileSync(G.stdoutFile,$.join(" ")+"\n")}catch(H){X(`Error writing to output file ${G.stdoutFile}: ${H}`)}else w(...$)};function b(...$){console.error(...$)}var X=function(...$){if(G.stderrFile)try{W.appendFileSync(G.stderrFile,$.join(" ")+"\n")}catch(H){X(`Error writing to error file ${G.stderrFile}: ${H}`)}else b(...$)};async function k($,H=8192){let q=!1,Q;try{Q=W.createReadStream($,{highWaterMark:H})}catch(K){if(K.code==="ENOENT")return!1;else throw K}for await(let K of Q)if(K instanceof Uint8Array){if(Array.from(K).some((J)=>J>127)){q=!0,Q.destroy();break}}return q}async function _($,H){try{if(H.nbconvertName&&$.endsWith(".ipynb"))if(H.nbconvertName==="internal")await v($,H);else await E($,H);else if(await k($))X(`Warning: Skipping binary file ${$}`);else{const q=W.readFileSync($,"utf8");Z($),Z("---"),Z(q),Z("---")}}catch(q){X(`Error processing file ${$}: ${q}`)}}async function v($,H){try{const q=await W.promises.readFile($,"utf8"),Q=JSON.parse(q);let K="";if(H.nbconvertFormat==="asciidoc")K=S(Q);else K=D(Q);Z(`${$}`),Z("---"),Z(K),Z("---")}catch(q){X(`Error converting .ipynb file ${$}: ${q}`)}}var S=function($){let H="";for(let q of $.cells)switch(q.cell_type){case"code":H+=`+*In[${q.execution_count}]:*+\n[source, ipython3]\n----\n${q.source.join("")}\n----\n\n`;for(let Q of q.outputs)if(Q.data["text/plain"])H+=`+*Out[${q.execution_count}]:*+\n----\n${Q.data["text/plain"]}\n----\n\n`;break;case"markdown":H+=`${q.source.join("")}\n\n`;break}return H},D=function($){let H="";for(let q of $.cells)switch(q.cell_type){case"code":H+=`\`\`\`python\n${q.source.join("")}\n\`\`\`\n\n`;for(let Q of q.outputs)if(Q.data["text/plain"])H+=`\`\`\`\n${Q.data["text/plain"]}\n\`\`\`\n\n`;break;case"markdown":H+=`${q.source.join("")}\n\n`;break}return H};async function E($,H){const q=await W.promises.mkdtemp(z.join(V.tmpdir(),"files-to-prompt-")),Q=z.join(q,z.basename($));try{await W.promises.copyFile($,Q);const K=`${H.nbconvertName} --to ${H.nbconvertFormat} "${Q}"`;try{O(K,{stdio:"inherit"})}catch(N){X(`Error running ${H.nbconvertName}: ${N}`);return}const J=H.nbconvertFormat==="markdown"?".md":`.${H.nbconvertFormat}`,Y=z.join(q,`${z.basename($,".ipynb")}${J}`),B=await W.promises.readFile(Y,"utf8");Z(`${$}`),Z("---"),Z(B),Z("---")}catch(K){X(`Error converting .ipynb file ${$}: ${K}`)}finally{await W.promises.rm(q,{recursive:!0,force:!0})}}var U=function($,H){const{ignorePatterns:q,gitignoreRules:Q}=H;for(let K of[...Q,...q]){if(j(z.basename($),K))return!0;if(K.endsWith("/")){const J=K.slice(0,-1);if(j(z.relative(z.dirname($),$),J))return!0}}return!1},F=function($){const H=z.join($,".gitignore");if(W.existsSync(H))return W.readFileSync(H,"utf8").split("\n").filter((q)=>q.trim()!==""&&!q.startsWith("#")).map((q)=>q.trim());return[]},j=function($,H){return new RegExp(`^${H.replace(/\*/g,".*")}\$`).test($)};async function x($,H){if(W.statSync($).isFile()){if(!U($,H))await _($,H)}else if(W.statSync($).isDirectory()){let q=H;if(H.gitignoreRules.length===0){const J=H.ignoreGitignore?[]:F($);if(J.length>0)q=structuredClone(H),q.gitignoreRules=J}const Q=W.readdirSync($,{withFileTypes:!0}).filter((J)=>H.includeHidden||!J.name.startsWith(".")).filter((J)=>J.isFile()).map((J)=>z.join($,J.name)),K=W.readdirSync($,{withFileTypes:!0}).filter((J)=>H.includeHidden||!J.name.startsWith(".")).filter((J)=>J.isDirectory()).map((J)=>z.join($,J.name));for(let J of Q)if(!U(J,q))await _(J,q);for(let J of K)if(!U(J,q))await x(J,q)}else X(`Skipping ${$}: unsupported file type`)}async function m(){return new Promise(($,H)=>{let q="";process.stdin.on("data",(Q)=>{q+=Q.toString()}),process.stdin.on("end",()=>{$(q)}),process.stdin.on("error",(Q)=>{H(Q)})})}function T($){const H=[],q=new Set,Q=$.trim().split("\n");for(let K of Q){const J=K.trim();if(J==="")continue;if(J.includes(":")){const Y=J.split(":");if(A(Y[0])&&!q.has(Y[0]))q.add(Y[0]),H.push(Y[0])}else if(A(J)&&!q.has(J))q.add(J),H.push(J)}return H}var A=function($){for(let H of $)if(H.charCodeAt(0)<32||H.charCodeAt(0)>126)return!1;if($.length>1024)return!1;return!0},y=function($,H,q,Q){for(let K=0;K<$.length;K++){const J=$[K];switch(J){case"--version":return Z(`files-to-prompt.ts ${R}`),!1;case"--include-hidden":q.includeHidden=!0;break;case"--ignore-gitignore":q.ignoreGitignore=!0;break;case"-i":case"--ignore":if(K+1<$.length)q.ignorePatterns.push($[++K]);else return X("Error: --ignore option requires a pattern"),!0;break;case"--output":case"-o":if(K+1<$.length){Q.stdoutFile=$[++K];try{W.writeFileSync(Q.stdoutFile,""),W.truncateSync(Q.stdoutFile)}catch(Y){return X(`Error writing to output file ${Q.stdoutFile}: ${Y}`),Q.stdoutFile="",!0}}else return X("Error: --output option requires a file path"),!0;break;case"--nbconvert":if(K+1<$.length)q.nbconvertName=$[++K];else return X("Error: --nbconvert option requires the filename or full path of the tool or \'internal\'"),!0;if(q.nbconvertName!=="internal")try{O(`${q.nbconvertName} --version`,{stdio:"ignore"})}catch(Y){X(`Warning: ${q.nbconvertName} command not found`),q.nbconvertName=""}break;case"--format":if(K+1<$.length){const Y=$[++K];if(Y==="asciidoc"||Y==="markdown")q.nbconvertFormat=Y;else return X(`Error: Unsupported format '${Y}', use 'asciidoc' or 'markdown'`),!0}else return X("Error: --format option requires a format"),!0;break;default:if(J.startsWith("-"))return X(`Error: Unsupported option '${J}'`),!0;H.push(J)}}return!1};async function L($){const H={includeHidden:!1,ignoreGitignore:!1,ignorePatterns:[],gitignoreRules:[],nbconvertName:"",nbconvertFormat:"asciidoc"},q=[];if(y($,q,H,G))return;if(M.isNode&&!process.stdin.isTTY||M.isDeno&&!Deno.stdin.isTerminal()){const K=await m(),J=T(K);q.push(...J)}for(let K of q){if(!W.existsSync(K)){X(`Path does not exist: ${K}`);return}await x(K,H)}return}var R="v0.5.1",M={isDeno:!1,isNode:!1},G={stdoutFile:"",stderrFile:""};if(import.meta.main||process.argv[1]===I(import.meta.url))if(typeof Deno!=="undefined")M.isDeno=!0,await L(Deno.args);else M.isNode=!0,await L(process.argv.slice(2));export{T as parseFilePathsFromStdin,L as main,k as isBinaryFile,w as consoleOutput,b as consoleError};
