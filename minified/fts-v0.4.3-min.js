#!/usr/bin/env bun
// @bun
import O from"fs";import x from"os";import W from"path";import{fileURLToPath as B} from"url";import{execSync as j} from"child_process";function V(...q){console.log(...q)}var Y=function(...q){if(X.stdoutFile)try{O.appendFileSync(X.stdoutFile,q.join(" ")+"\n")}catch(A){Q(`Error writing to output file ${X.stdoutFile}: ${A}`)}else V(...q)};function v(...q){console.error(...q)}var Q=function(...q){if(X.stderrFile)try{O.appendFileSync(X.stderrFile,q.join(" ")+"\n")}catch(A){Q(`Error writing to error file ${X.stderrFile}: ${A}`)}else v(...q)};async function I(q,A=8192){let J=!1,K;try{K=O.createReadStream(q,{highWaterMark:A})}catch(M){if(M.code==="ENOENT")return!1;else throw M}for await(let M of K)if(M instanceof Uint8Array){if(Array.from(M).some((H)=>H>127)){J=!0,K.destroy();break}}return J}async function G(q,A){try{if(await I(q))Q(`Warning: Skipping binary file ${q}`);else if(A.nbconvertName&&q.endsWith(".ipynb"))await k(q,A);else{const J=O.readFileSync(q,"utf8");Y(q),Y("---"),Y(J),Y("---")}}catch(J){Q(`Error processing file ${q}: ${J}`)}}async function k(q,A){const J=await O.promises.mkdtemp(W.join(x.tmpdir(),"files-to-prompt-")),K=W.join(J,W.basename(q));try{await O.promises.copyFile(q,K);const M=`${A.nbconvertName} --to ${A.convertFormat} "${K}"`;try{j(M,{stdio:"inherit"})}catch(w){Q(`Error running ${A.nbconvertName}: ${w}`);return}const H=A.convertFormat==="markdown"?".md":`.${A.convertFormat}`,Z=W.join(J,`${W.basename(q,".ipynb")}${H}`),N=await O.promises.readFile(Z,"utf8");Y(`${q}`),Y("---"),Y(N),Y("---")}catch(M){Q(`Error converting .ipynb file ${q}: ${M}`)}finally{await O.promises.rm(J,{recursive:!0,force:!0})}}var b=function(q,A){const{ignorePatterns:J,gitignoreRules:K}=A;for(let M of[...K,...J]){if(L(W.basename(q),M))return!0;if(M.endsWith("/")){const H=M.slice(0,-1);if(L(W.relative(W.dirname(q),q),H))return!0}}return!1},D=function(q){const A=W.join(q,".gitignore");if(O.existsSync(A))return O.readFileSync(A,"utf8").split("\n").filter((J)=>J.trim()!==""&&!J.startsWith("#")).map((J)=>J.trim());return[]},L=function(q,A){return new RegExp(`^${A.replace(/\*/g,".*")}\$`).test(q)};async function z(q,A){if(O.statSync(q).isFile()){if(!b(q,A))await G(q,A)}else if(O.statSync(q).isDirectory()){let J=A;if(A.gitignoreRules.length===0){const H=A.ignoreGitignore?[]:D(q);if(H.length>0)J=structuredClone(A),J.gitignoreRules=H}const K=O.readdirSync(q,{withFileTypes:!0}).filter((H)=>A.includeHidden||!H.name.startsWith(".")).filter((H)=>H.isFile()).map((H)=>W.join(q,H.name)),M=O.readdirSync(q,{withFileTypes:!0}).filter((H)=>A.includeHidden||!H.name.startsWith(".")).filter((H)=>H.isDirectory()).map((H)=>W.join(q,H.name));for(let H of K)if(!b(H,J))await G(H,J);for(let H of M)if(!b(H,J))await z(H,J)}else Q(`Skipping ${q}: unsupported file type`)}async function S(){return new Promise((q,A)=>{let J="";process.stdin.on("data",(K)=>{J+=K.toString()}),process.stdin.on("end",()=>{q(J)}),process.stdin.on("error",(K)=>{A(K)})})}function E(q){const A=[],J=new Set,K=q.trim().split("\n");for(let M of K){const H=M.trim();if(H==="")continue;if(H.includes(":")){const Z=H.split(":");if(U(Z[0])&&!J.has(Z[0]))J.add(Z[0]),A.push(Z[0])}else if(U(H)&&!J.has(H))J.add(H),A.push(H)}return A}var U=function(q){for(let A of q)if(A.charCodeAt(0)<32||A.charCodeAt(0)>126)return!1;if(q.length>1024)return!1;return!0};async function _(q){const A={includeHidden:!1,ignoreGitignore:!1,ignorePatterns:[],gitignoreRules:[],nbconvertName:"",convertFormat:"asciidoc"};let J=[];for(let K=0;K<q.length;K++){const M=q[K];switch(M){case"--version":Y(`files-to-prompt.ts version ${R}`);return;case"--include-hidden":A.includeHidden=!0;break;case"--ignore-gitignore":A.ignoreGitignore=!0;break;case"-i":case"--ignore":if(K+1<q.length)A.ignorePatterns.push(q[++K]);else{Q("Error: --ignore option requires a pattern");return}break;case"--output":case"-o":if(K+1<q.length){X.stdoutFile=q[++K];try{O.writeFileSync(X.stdoutFile,""),O.truncateSync(X.stdoutFile)}catch(H){Q(`Error writing to output file ${X.stdoutFile}: ${H}`),X.stdoutFile="";return}}else{Q("Error: --output option requires a file path");return}break;case"--nbconvert":if(K+1<q.length)A.nbconvertName=q[++K];else{Q("Error: --nbconvert option requires the filename or full path of the tool");return}try{j(`${A.nbconvertName} --version`,{stdio:"ignore"})}catch(H){Q(`Warning: ${A.nbconvertName} command not found`),A.nbconvertName=""}break;case"--format":if(K+1<q.length){const H=q[++K];if(H==="asciidoc"||H==="markdown")A.convertFormat=H;else{Q(`Error: Unsupported format '${H}', use 'asciidoc' or 'markdown'`);return}}else{Q("Error: --format option requires a format");return}break;default:if(M.startsWith("-")){Q(`Error: Unsupported option '${M}'`);return}J.push(M)}}if($.isNode&&!process.stdin.isTTY||$.isDeno&&!Deno.stdin.isTerminal()){const K=await S(),M=E(K);J.push(...M)}for(let K of J){if(!O.existsSync(K)){Q(`Path does not exist: ${K}`);return}await z(K,A)}return}var R="0.4.3",$={isDeno:!1,isNode:!1},X={stdoutFile:"",stderrFile:""};if(import.meta.main||process.argv[1]===B(import.meta.url))if(typeof Deno!=="undefined")$.isDeno=!0,await _(Deno.args);else $.isNode=!0,await _(process.argv.slice(2));export{E as parseFilePathsFromStdin,_ as main,I as isBinaryFile,V as consoleOutput,v as consoleError};
